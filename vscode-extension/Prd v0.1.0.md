PRD · Python 阅读注释插件（v1）
1. 产品背景与动机

Python 初学者在阅读代码时，常常卡在以下位置：

不理解基础符号的含义（如 =、==、.、()、[]、\n）

VS Code 已有 Hover 信息偏向技术层面（类型、签名、docstring），对 0 基础用户不友好

需要频繁在 IDE 与搜索/ChatGPT 之间切换，打断阅读节奏

本插件旨在解决的不是“如何写代码”，而是：

如何把正在看的 Python 代码“读懂”。

2. 产品定位（一句话）

一个面向 Python 初学者的 VS Code 插件，
在不替代 VS Code 原生能力的前提下，
为代码行与符号提供可直接阅读的中文注释解释。

3. 目标用户

Python 零基础 / 初学阶段用户

能运行代码，但无法顺畅阅读代码

对语法符号、字符串转义、调用结构理解不清晰

使用 VS Code + Python 插件（Pylance）

非目标用户

有系统编程经验的中高级 Python 用户

以类型系统、性能、最佳实践为主要关注点的用户

4. 核心设计原则（必须遵守）

保留标准术语

使用 Python 官方 / 社区通用术语（assignment, function, slice 等）

不创造私有名词（如“步骤包”）

解释是“注释”，不是“教学”

一句话说明“在干嘛”

不展开完整语言原理

不要求用户提问

无 prompt

所见即解释

叠加而非替代 VS Code

不修改、不拦截原生 Hover

只新增“初学者解释区”

5. 核心功能（v1）
5.1 行级解释（Line-level Explanation）

触发方式

光标悬停在某一行（或行内任意位置）

输出内容

1～2 句中文说明该行整体在做什么

示例

print("First 10 labels:\n", y[:10].astype(int))


调用 print 打印两样内容：
一段文字和一组数字，其中 \n 用来换行显示。

5.2 符号级解释（Token-level Explanation）

触发方式

Hover 时自动识别当前行出现的关键符号

或光标直接落在符号上

覆盖范围（v1 必须支持）

赋值与更新：=, +=, -=

比较：==, !=

调用与访问：., (), []

分隔：,

关键字：def, return, import

字符串转义：\n, \t, \\, \"

示例（点中 \n）

\n（换行符）
在字符串中表示“从这里开始换一行显示”。

5.3 原生 Hover 的中文“认知翻译”

当 VS Code / Pylance 已提供 Hover 信息时：

插件不复写原文

在 Hover 中追加一段 “简化中文说明”

示例
原生 Hover：

randn(*args) -> ndarray


插件追加：

中文解释（简化）：
randn 用来生成随机数，返回一组表格状的数据。

6. UI 形态
6.1 统一使用 VS Code Hover

不引入新窗口

不使用浮动 Webview

与原生 Hover 同一面板显示

6.2 Hover 内容结构（固定）
────────────────────
🔰 初学者解释（插件）

【行解释】
【符号解释列表】

[展开更多]
────────────────────
原生 Hover（Pylance）

7. Layer 设计（折叠解释）
Layer 1（默认）

标准术语 + 一句话解释

面向“正在读代码”

Layer 2（点击展开）

常见误解澄清

极小对比示例

更口语化说明

8. 技术实现原则（v1）

不强制使用 LLM

规则库 + Python tokenize / AST 解析

行类型 + 符号表驱动生成解释

可选（v1.5）

LLM 仅用于：

对结构化解释进行语言润色

且可关闭

9. 明确不做的事情（防止膨胀）

不讲类型系统（ndarray / dtype / generics）

不跨行推理复杂逻辑

不解释算法意图

不试图“教会 Python”

10. v1 成功标准（验收）

用户能回答：

“这一行代码在干嘛？”

用户能明确区分：
= vs ==、. vs ()、\n 的作用

减少频繁离开 VS Code 查资料的行为

11. 下一步开发顺序（建议）

建立 symbols.json（完整符号表）

支持 HoverProvider + 行解析

先覆盖 20～30 个最常见符号

用你自己的学习过程做 Dogfooding

1) symbols.json 放哪：插件目录内 vs 用户可配置？

v1：放在插件目录内（extension bundle）作为内置规则库。

理由：

稳定：你控制版本，不会被用户改坏

易发布：随扩展打包

易迭代：后续升级规则库跟着扩展版本走

v1.5 才做用户可配置（可选）

加一个设置项：tokenTutor.symbolsPath

若用户提供路径：优先加载外部 JSON

否则：用内置默认

这样既满足高级用户“自定义解释”的需求，又不影响 v1 落地。

2) 字符串内符号：是否跳过字符串内的符号解释？

v1：跳过“字符串内部的一般符号”，但保留“转义符”解释。

也就是：

✅ 解释：\n, \t, \\, \", \', \r（至少 v1 前四个）

❌ 不解释：字符串里的 =、[]、. 之类（因为它们只是文本，不是代码语义）

为什么这样最稳？

避免误导：字符串里的 == 只是字符，不是比较

依然覆盖你真实痛点：转义符

实现上你可以做一个简单判断：

若光标在字符串 token 内：只提供“转义符类”的 Hover（或行级总结），不做普通符号扫描

3) Layer2 展开：Markdown 折叠还是其他方式？

v1：用 Markdown <details> 折叠。

理由：

实现成本最低

不需要命令路由、不需要额外 UI

和 Hover 场景天然匹配

格式示例（Hover Markdown）：

**=（赋值）**：把右边结果保存到左边变量。

<details>
<summary>展开更多</summary>

- 不是比较，不会得到 True/False  
- 对比：
  - `x = 3`：赋值（改变量）
  - `x == 3`：比较（True/False）
</details>


v1.5（可选）

需要更强交互时再用 command links（command:...）+ 自己维护展开状态

但 v1 不建议上这个复杂度

4) 优先级：先符号解释还是行级总结，或并行？

v1：先符号解释，再加“极简行级总结”。

更具体一点的里程碑顺序：

✅ HoverProvider 能显示内容（不管内容）

✅ 符号解释（从 symbols.json 查询，输出 Layer1）

✅ Layer2 折叠

✅ 行级总结（只做 5 类模板）

def ...:

return ...

name = ...

print(...)

import / from ... import ...

（可选）增加更多行模式：if/for/while/with/try

原因：符号解释是你对 VS Code 的“独占补齐”，投入产出比最高；行级总结容易陷入语义泥潭，所以控制范围到模板即可。